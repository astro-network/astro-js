//! Circuit for a verifiable vector clock, suitable for p2p systems.

use std::array::truncate;
use std::convert::from_bits_unsigned;
use std::crypto::sha256;

/// The length of the clock, i.e. number of indices.
const M: u8 = 8;
/// The number of hashes to produce, i.e. indices to increment.
const K: u8 = 2;

/// The inner type of the counting clock. Should be large enough to avoid overflows.
type Counter = u248;
const COUNTER_SIZE: u8 = 248;
const ZERO: Counter = 0;
/// The digest type that this counter tracks.
type Digest = [bool; COUNTER_SIZE];

/// A basic, verifiable Bloom clock: [arXiv:1905.13064].
///
/// [arXiv:1905.13064]: https://arxiv.org/pdf/1905.13064.pdf.
struct Clock {
    inner: [Counter; M],
}

/// Represents a partial order between two types.
enum Ord {
    Less = 0,
    Equal = 1,
    Greater = 2,
    Concurrent = 3,
}

impl Ord {
    fn compare_counters(ours: Counter, theirs: Counter) -> Ord {
        if ours < theirs {
            Ord::Less
        } else if ours == theirs {
            Ord::Equal
        } else {
            Ord::Greater
        }
    }

    fn compare_clocks(ours: Clock, theirs: Clock) -> Ord {
        let mut first = true;
        let mut ord = Ord::Concurrent;

        for i in 0..M {
            let l = ours.inner[i];
            let r = theirs.inner[i];

            if first {
                first = false;
                ord = Ord::compare_counters(l, r)
            } else {
                ord = match ord {
                    Ord::Less => {
                        if l <= r {
                            ord
                        } else {
                            Ord::Concurrent
                        }
                    },
                    Ord::Equal => Ord::compare_counters(l, r),
                    Ord::Greater => {
                        if l >= r {
                            ord
                        } else {
                            Ord::Concurrent
                        }
                    },
                    _ => Ord::Concurrent,
                };
            }
        }

        ord
    }
}

impl Clock {
    /// Returns an index in 0..M and the next digest of the provided `Digest`.
    /// TODO: pedersen vs sha256?
    fn hash(digest: Digest) -> (u8, Digest) {
        let next_digest = truncate(sha256(digest), COUNTER_SIZE);
        let mut ones: u8 = 0;
        for i in 0..COUNTER_SIZE {
            if next_digest[i] {
                ones += 1;
            }
        }
        (ones, next_digest)
    }

    /// Increments the clock with the new digest.
    fn increment(mut clock: Clock, digest: Digest) {
        let mut output = (0, digest);
        for _i in 0..K {
            output = Clock::hash(output.1);
            clock.inner[output.0] += (1 as u248);
        }
    }

    /// Merges another `Clock` into `self`.
    fn merge(mut ours: Clock, theirs: Clock) {
        for i in 0..M {
            if theirs.inner[i] > ours.inner[i] {
                ours.inner[i] = theirs.inner[i];
            }
        }
    }

    /// Determines the partial ordering between two `Clock`s.
    fn compare(ours: Clock, theirs: Clock) -> Ord {
        Ord::compare_clocks(ours, theirs)
    }

    /// If our `Clock` is less than theirs, return true and the diff.
    /// Else, return false and 0.
    fn lt(ours: Clock, theirs: Clock) -> (bool, Counter) {
        let mut is_lt = true;
        let mut diff: Counter = ZERO;
        for i in 0..M {
            if is_lt {
                if ours.inner[i] <= theirs.inner[i] {
                    diff += (theirs.inner[i] - ours.inner[i]);
                } else {
                    is_lt = false;
                    diff = ZERO;
                }
            }
        }
        (is_lt, diff)
    }
}
