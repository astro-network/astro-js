use crate::types::{Address, Amount, BlockNumber, Sha256Hash};

///
pub struct Offer {
    /// Flags used to configure the offer's mutability invariants.
    flags: Flags,
    ///
    counterparty_asset_address: Address,
    // /// Block number after which this offer will expire.
    // expiry_block_no: BlockNumber,
    /// Maximum amount of the asset the owner is willing to hold in the offer.
    limit: Amount,
    /// Current amount of the asset the owner holds in the offer.
    balance: Amount,
    // ///
    // bid: u64,
    // ///
    // ask: u64,
    /// Associated offer metadata; likely stored in IPFS.
    metadata: Sha256Hash,
}

impl Offer {
    pub fn is_empty(self) -> bool {
        self.limit == 0 && self.balance == 0
    }

    /// Spends or exercises some part of an offer, returning the recipient
    /// address.
    pub fn spend(
        mut self,
        owner: Address,
        sender: Address,
        amount: Amount,
    ) -> Address {
        if !first {
            require(!self.is_personal(), "");
        }

        if sender == owner {
            // sender is spending retained balance
            require(self.flags.is_bidirectional(), "");
            require(amount <= self.balance, "");

            self.balance -= amount;
            counterparty_asset_address
        } else if sender == counterparty_asset_address {
            // sender is exercising offered balance
            self.balance += amount;

            require(self.balance <= self.limit, "");
            owner
        } else {
            require(false, "not allowed to spend or exercise offer");
        }
    }
}

/// Gets an offer from the
pub fn get_offer_strict(offers: OffersMap, owner: Address, offer_idx: u16) -> Offer {
    let (offer_list, offer_list_exists) = offers.get(owner);
    require(offer_list_exists, "account does not exist");

    let offer = offer_list[offer_idx];
    require(!offer.is_empty(), "offer does not exist");

    offer
}

///
/// Flag bits:
/// 0. immutability: all offer fields (except balance) are immutable and
///     henceforth cannot be changed.
/// 1. bidirectionality: any offer balance can be spent by both the offer owner
///     (down to zero) and the recipient (up to offer limit).
/// 2. personal: can only be spent or exercised directly, not as an intermediate
///     offer in a path payment.
struct Flags {
    inner: [bool; 8],
}

impl Flags {
    fn is_immutable(self) -> bool {
        self.inner[0]
    }

    fn is_bidirectional(self) -> bool {
        self.inner[1]
    }
}
