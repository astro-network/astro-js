//!
//! The 'circuits-zinc' circuit entry.
//!
//! owner account tree height: 32
//! asset tree height: 16
//! offer tree height: 8
//!
//! transaction: submitted by users
//! operation:

mod constants;
mod operations;
mod types;

use std::collections::MTreeMap;

contract Datalove {
    ///
    pub const VERSION: u8 = 0;

    ///
    offers: MTreeMap<types::Address, [types::offer::Offer; 1]>;

    ///
    pub fn new() -> Self {
        Self { offers: MTreeMap }
    }

    // Main Datalove Operations

    // ///
    // pub fn create_offer(
    //     mut self,
    //     offer_idx: u16,
    //     flags_int: u8,
    //     counterparty_asset_address: types::Address,
    //     limit: types::Amount,
    //     balance: types::Amount,
    //     metadata: types::Sha256Hash
    // ) {
    //     operations::create_offer::do(
    //         self.offers,
    //         zksync::msg.sender,
    //         offer_idx,
    //         flags_int,
    //         counterparty_asset_address,
    //         limit,
    //         balance,
    //         metadata,
    //     )
    // }

    // ///
    // pub fn update_offer_flags(mut self, offer_idx: u16, flags_int: u8, metadata: types::Sha256Hash) {
    //     require(false, "unimplemented");
    // }

    // ///
    // pub fn update_offer_limit(mut self, offer_idx: u16, new_limit: types::Amount, metadata: types::Sha256Hash) {
    //     require(false, "unimplemented");
    // }

    ///
    pub fn path_payment(
        mut self,
        recipient: types::Address,
        spend_amount: types::Amount,
        path: types::offer::OfferPath,
        // metadata: types::Sha256Hash
    ) {
        let mut path_index = types::offer::PathIndex::First;
        let mut current_sender = zksync::msg.sender;

        for i in 0..7 while path_index != types::offer::PathIndex::Last {
            let (offer_addr, offer_idx) = path[i];
            let mut offer = self.get_offer_strict(offer_addr, offer_idx);

            current_sender = if path_index == types::offer::PathIndex::First {
                path_index = types::offer::PathIndex::Other;
                offer.spend(offer_addr, current_sender, spend_amount, true)
            } else {
                offer.spend(offer_addr, current_sender, spend_amount, false)
            };

            if current_sender == recipient {
                path_index = types::offer::PathIndex::Last;
            }
        }

        require(current_sender == recipient, "path payment does not end with recipient");

        // dbg!("payment metadata: {}", metadata);
    }

    ///
    fn get_offer(self, owner: types::Address, offer_idx: u16) -> (types::offer::Offer, bool) {
        let (offer_list, offer_list_exists) = self.offers.get(owner);
        require(offer_list_exists, "account does not exist");

        let offer = offer_list[offer_idx];
        (offer, !offer.is_empty())
    }

    /// Gets an offer from the offer map, requiring that it exists.
    fn get_offer_strict(self, owner: types::Address, offer_idx: u16) -> types::offer::Offer {
        let (offer, offer_exists) = self.get_offer(owner, offer_idx);
        require(offer_exists, "offer does not exist");

        offer
    }
}
